module ModalLogic where

-- Implement Frank Pfenning's lambda calculus based on modal logic S4, as
-- described in "A Modal Analysis of Staged Computation".

open import Denotational.Notation

data BaseType : Set where
  Base : BaseType
  Next : BaseType → BaseType

data Type : Set where
  base : BaseType → Type
  _⇒_ : Type → Type → Type
  □_ : Type → Type

-- Reuse contexts, variables and weakening from Tillmann's library.
open import Syntactic.Contexts Type

-- No semantics for these types.

data Term : Context → Context → Type → Set where
  abs : ∀ {τ₁ τ₂ Γ Δ} → (t : Term (τ₁ • Γ) Δ τ₂) → Term Γ Δ (τ₁ ⇒ τ₂)
  app : ∀ {τ₁ τ₂ Γ Δ} → (t₁ : Term Γ Δ (τ₁ ⇒ τ₂)) (t₂ : Term Γ Δ τ₁) → Term Γ Δ τ₂
  ovar : ∀ {Γ Δ τ} → (x : Var Γ τ) → Term Γ Δ τ
  mvar : ∀ {Γ Δ τ} → (u : Var Δ τ) → Term Γ Δ τ
  -- Note the builtin weakening
  box : ∀ {Γ Δ τ} → Term ∅ Δ τ → Term Γ Δ (□ τ)
  let-box_in-_ : ∀ {τ₁ τ₂ Γ Δ} → (e₁ : Term Γ Δ (□ τ₁)) → (e₂ : Term Γ (τ₁ • Δ) τ₂) → Term Γ Δ τ₂

-- Lemma 1 includes weakening.
-- Attempt 1 at weakening, subcontext-based. This works, but it is not what we need later.
--
-- Most of the proof can be generated by C-c C-a, but syntax errors must then be
-- fixed and lift introduced by hand.

weaken : ∀ {Γ₁ Γ₂ Δ₁ Δ₂ τ} → (Γ′ : Γ₁ ≼ Γ₂) → (Δ′ : Δ₁ ≼ Δ₂) → Term Γ₁ Δ₁ τ → Term Γ₂ Δ₂ τ
weaken Γ′ Δ′ (abs {τ₁} t) = abs (weaken (keep τ₁ • Γ′) Δ′ t)
weaken Γ′ Δ′ (app t t₁) = app (weaken Γ′ Δ′ t) (weaken Γ′ Δ′ t₁)
weaken Γ′ Δ′ (ovar x) = ovar (lift Γ′ x)
weaken Γ′ Δ′ (mvar u) = mvar (lift Δ′ u)
weaken Γ′ Δ′ (box t) = box (weaken ∅ Δ′ t)
weaken Γ′ Δ′ (let-box_in-_ {τ₁} t t₁) =
  let-box weaken Γ′ Δ′ t in-
          weaken Γ′ (keep τ₁ • Δ′) t₁


open import Relation.Binary.PropositionalEquality

weaken-≼ : ∀ {Γ₁ Γ₂ Γ₃ Δ τ} → Term (Γ₁ ⋎ Γ₃) Δ τ → Term (Γ₁ ⋎ Γ₂ ⋎ Γ₃) Δ τ
weaken-≼ {Γ₁} {Γ₂} {Γ₃} (abs {τ₁} t) =  abs (weaken-≼ {τ₁ • Γ₁} {Γ₂} t)
weaken-≼ {Γ₁} {Γ₂} (app t t₁) = app (weaken-≼ {Γ₁} {Γ₂} t) (weaken-≼ {Γ₁} {Γ₂} t₁)
weaken-≼ {Γ₁} {Γ₂} (ovar x) = ovar (Prefixes.lift {Γ₁} {Γ₂} x)
weaken-≼ (mvar u) = mvar u
weaken-≼ (box t) = box t
weaken-≼ {Γ₁} {Γ₂} (let-box t in- t₁) = let-box weaken-≼ {Γ₁} {Γ₂} t in- weaken-≼ {Γ₁} {Γ₂} t₁

substVar : ∀ {Γ Γ′ Δ τ₁ τ₂} → (t : Term Γ′ Δ τ₁) → (v : Var (Γ ⋎ (τ₁ • Γ′)) τ₂) → Term (Γ ⋎ Γ′) Δ τ₂
substVar {∅} t  this = t
substVar {∅} t (that v) = ovar v
substVar {τ • Γ} t  this = ovar this
substVar {τ • Γ} t (that v) = weaken-≼ {∅} {τ • ∅} (substVar {Γ} t v)

substTerm : ∀ {Γ Γ′ Δ τ₁ τ₂} → (t₁ : Term Γ′ Δ τ₁) → (t₂ : Term (Γ ⋎ (τ₁ • Γ′)) Δ τ₂) → Term (Γ ⋎ Γ′) Δ τ₂
substTerm {Γ} {Γ′} t₁ (abs {τ₂} t₂) = abs ( substTerm {τ₂ • Γ} {Γ′} t₁ t₂ )
substTerm {Γ} {Γ′} t₁ (app t₂ t₃) =  app (substTerm {Γ} {Γ′} t₁ t₂) (substTerm {Γ} {Γ′} t₁ t₃) 
substTerm {Γ} {Γ′} t₁ (ovar v) =  substVar {Γ} {Γ′} t₁ v
substTerm t₁ (mvar u) = mvar u
substTerm t₁ (box t₂) = box t₂
substTerm {Γ} {Γ′} t₁ (let-box_in-_ {τ₃} t₂ t₃) =
  let-box substTerm {Γ} {Γ′} t₁ t₂ in-
    substTerm {Γ} {Γ′}
      (weaken ≼-refl (drop τ₃ • ≼-refl) t₁)
      t₃
